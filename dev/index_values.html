<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Formula_intf" rel="Chapter" href="Formula_intf.html">
<link title="Theory_intf" rel="Chapter" href="Theory_intf.html">
<link title="Plugin_intf" rel="Chapter" href="Plugin_intf.html">
<link title="Expr_intf" rel="Chapter" href="Expr_intf.html">
<link title="Res_intf" rel="Chapter" href="Res_intf.html">
<link title="Solver_types_intf" rel="Chapter" href="Solver_types_intf.html">
<link title="Solver_intf" rel="Chapter" href="Solver_intf.html">
<link title="Tseitin_intf" rel="Chapter" href="Tseitin_intf.html">
<link title="Res" rel="Chapter" href="Res.html">
<link title="Internal" rel="Chapter" href="Internal.html">
<link title="External" rel="Chapter" href="External.html">
<link title="Solver_types" rel="Chapter" href="Solver_types.html">
<link title="Solver" rel="Chapter" href="Solver.html">
<link title="Mcsolver" rel="Chapter" href="Mcsolver.html">
<link title="Tseitin" rel="Chapter" href="Tseitin.html">
<link title="Dot" rel="Chapter" href="Dot.html">
<link title="Dedukti" rel="Chapter" href="Dedukti.html">
<link title="Backend_intf" rel="Chapter" href="Backend_intf.html">
<link title="Sat" rel="Chapter" href="Sat.html">
<link title="Expr_sat" rel="Chapter" href="Expr_sat.html">
<link title="Type_sat" rel="Chapter" href="Type_sat.html">
<link title="Smt" rel="Chapter" href="Smt.html">
<link title="Expr_smt" rel="Chapter" href="Expr_smt.html">
<link title="Type_smt" rel="Chapter" href="Type_smt.html">
<link title="Unionfind" rel="Chapter" href="Unionfind.html">
<link title="Mcsat" rel="Chapter" href="Mcsat.html">
<link title="Eclosure" rel="Chapter" href="Eclosure.html">
<link title="Plugin_mcsat" rel="Chapter" href="Plugin_mcsat.html"><title>mSAT doc : Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALadd_assign">add_assign</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALadd_atom">add_atom</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Returns the atom associated with the given formula
</div>
</td></tr>
<tr><td><a href="Eclosure.S.html#VALadd_eq">add_eq</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALadd_job">add_job</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Eclosure.S.html#VALadd_neq">add_neq</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td><div class="info">
Add an equality of inequality to the closure.
</div>
</td></tr>
<tr><td><a href="Eclosure.S.html#VALadd_tag">add_tag</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td><div class="info">
Add a tag to an expression.
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALadd_term">add_term</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Returns the variable associated with the term
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALadd_watch">add_watch</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Term.html#VALapply">apply</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
Applies a constant function to type arguments, then term arguments
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALapply">apply</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td><div class="info">
Applies a constant to a list of types
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALassign">assign</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_intf.S.html#VALassign">assign</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Returns an assignment value for the given term.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALassume">assume</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALassume">assume</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Add the list of clauses to the current set of assumptions.
</div>
</td></tr>
<tr><td><a href="Solver_intf.S.html#VALassume">assume</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Add the list of clauses to the current set of assumptions.
</div>
</td></tr>
<tr><td><a href="Plugin_intf.S.html#VALassume">assume</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Assume the formulas in the slice, possibly pushing new formulas to be propagated,
      and returns the result of the new assumptions.
</div>
</td></tr>
<tr><td><a href="Theory_intf.S.html#VALassume">assume</a> [<a href="Theory_intf.S.html">Theory_intf.S</a>]</td>
<td><div class="info">
Assume the formulas in the slice, possibly pushing new formulas to be propagated,
      and returns the result of the new assumptions.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALatom">atom</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALbacktrack">backtrack</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_intf.S.html#VALbacktrack">backtrack</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Backtrack to the given level.
</div>
</td></tr>
<tr><td><a href="Theory_intf.S.html#VALbacktrack">backtrack</a> [<a href="Theory_intf.S.html">Theory_intf.S</a>]</td>
<td><div class="info">
Backtrack to the given level.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALbase">base</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td><div class="info">
The type of propositions and individuals
</div>
</td></tr>
<tr><td><a href="Expr_smt.Id.html#VALbase">base</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Constants representing the type for propositions and a default type
      for term, respectively.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.S.html#VALbind">bind</a> [<a href="Expr_smt.Subst.S.html">Expr_smt.Subst.S</a>]</td>
<td><div class="info">
<code class="code">bind v t subst</code> returns the same substitution as <code class="code">subst</code> with the additional binding from <code class="code">v</code> to <code class="code">t</code>.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALbindings">bindings</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Returns the list of bindings ofa substitution.
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALchain_eq">chain_eq</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALcheck">check</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Check the satisfiability of the current model.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALcheck">check</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Check the contents of a proof.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALchoose">choose</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Return one binding of the given substitution, or raise Not_found if the substitution is empty.
</div>
</td></tr>
<tr><td><a href="Eclosure.Key.html#VALcompare">compare</a> [<a href="Eclosure.Key.html">Eclosure.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Unionfind.OrderedType.html#VALcompare">compare</a> [<a href="Unionfind.OrderedType.html">Unionfind.OrderedType</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALcompare">compare</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Usual hash/compare functions
</div>
</td></tr>
<tr><td><a href="Expr_smt.Term.html#VALcompare">compare</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
Usual hash/compare functions
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALcompare">compare</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td><div class="info">
Usual hash/compare functions
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALcompare">compare</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALcompare">compare</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Usual functions for hash/comparison
</div>
</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALconst_ttype">const_ttype</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Print.html#VALconst_ty">const_ty</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Dedukti.Arg.html#VALcontext">context</a> [<a href="Dedukti.Arg.html">Dedukti.Arg</a>]</td>
<td></td></tr>
<tr><td><a href="Eclosure.S.html#VALcreate">create</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td><div class="info">
Creates an empty state which uses the given backtrack stack
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALcurrent_level">current_level</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_intf.S.html#VALcurrent_level">current_level</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Return the current level of the theory (either the empty/beginning state, or the
      last level returned by the <code class="code">assume</code> function).
</div>
</td></tr>
<tr><td><a href="Theory_intf.S.html#VALcurrent_level">current_level</a> [<a href="Theory_intf.S.html">Theory_intf.S</a>]</td>
<td><div class="info">
Return the current level of the theory (either the empty/beginning state, or the
      last level returned by the <code class="code">assume</code> function).
</div>
</td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Log.html#VALdebug">debug</a> [<a href="Log.html">Log</a>]</td>
<td><div class="info">
Simpler version of <a href="Log.html#VALdebug"><code class="code">Log.debug</code></a>, without formatting
</div>
</td></tr>
<tr><td><a href="Log.html#VALdebugf">debugf</a> [<a href="Log.html">Log</a>]</td>
<td><div class="info">
Emit a debug message at the given level.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALdummy">dummy</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALdummy">dummy</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
A dummy atom, different from any other atom.
</div>
</td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALdummy">dummy</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td><div class="info">
Formula constants.
</div>
</td></tr>
<tr><td><a href="Plugin_intf.S.html#VALdummy">dummy</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
A dummy level.
</div>
</td></tr>
<tr><td><a href="Theory_intf.S.html#VALdummy">dummy</a> [<a href="Theory_intf.S.html">Theory_intf.S</a>]</td>
<td><div class="info">
A dummy level.
</div>
</td></tr>
<tr><td><a href="Formula_intf.S.html#VALdummy">dummy</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td><div class="info">
Formula constants.
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALdummy_atom">dummy_atom</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALdummy_clause">dummy_clause</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Dummy values for use in vector dummys
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALdummy_var">dummy_var</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALelt_of_lit">elt_of_lit</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALelt_of_var">elt_of_var</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Constructors &amp; destructor for elements
</div>
</td></tr>
<tr><td><a href="Unionfind.Make.html#VALempty">empty</a> [<a href="Unionfind.Make.html">Unionfind.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALempty">empty</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
The empty substitution
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALempty_clause">empty_clause</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
The empty clause
</div>
</td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALeq">eq</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Create an equality over two terms.
</div>
</td></tr>
<tr><td><a href="Eclosure.Key.html#VALequal">equal</a> [<a href="Eclosure.Key.html">Eclosure.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALequal">equal</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Term.html#VALequal">equal</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALequal">equal</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALequal">equal</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Comparison and hash functions, with a comparison/hash function on values as parameter
</div>
</td></tr>
<tr><td><a href="Expr_smt.Id.html#VALequal">equal</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALequal">equal</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_intf.S.Term.html#VALequal">equal</a> [<a href="Expr_intf.S.Term.html">Expr_intf.S.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Formula_intf.S.html#VALequal">equal</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALeval">eval</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALeval">eval</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the valuation of a formula in the current state
      of the sat solver.
</div>
</td></tr>
<tr><td><a href="Plugin_intf.S.html#VALeval">eval</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Returns the evaluation of the formula in the current assignment
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALeval_level">eval_level</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Return the current assignement of the literals, as well as its
      decision level.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALexists">exists</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Tests wether the predicate holds for at least one binding.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALexpand">expand</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Return the proof step at the root of a given proof.
</div>
</td></tr>
<tr><td><a href="Solver_intf.S.html#VALexport_dimacs">export_dimacs</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Prints the entire set of clauses in the input problem
      (including hypothesis, lemmas and local assumptions),
      in the dimacs format.
</div>
</td></tr>
<tr><td><a href="Solver_intf.S.html#VALexport_icnf">export_icnf</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Export the current problem contents to iCNF format.
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALf_false">f_false</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALf_true">f_true</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALfalse_">false_</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Eclosure.S.html#VALfind">find</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td><div class="info">
Returns the representative of the given expression in the current closure state
</div>
</td></tr>
<tr><td><a href="Unionfind.Make.html#VALfind">find</a> [<a href="Unionfind.Make.html">Unionfind.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Eclosure.S.html#VALfind_tag">find_tag</a> [<a href="Eclosure.S.html">Eclosure.S</a>]</td>
<td><div class="info">
Returns the tag associated with the equality class of the given term, if any.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALfold">fold</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Fold over the elements
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALfold">fold</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
<code class="code">fold f acc p</code>, fold <code class="code">f</code> over the proof <code class="code">p</code> and all its node.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALfor_all">for_all</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Tests wether the predicate holds for all bindings.
</div>
</td></tr>
<tr><td><a href="Unionfind.Make.html#VALforbid">forbid</a> [<a href="Unionfind.Make.html">Unionfind.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALfresh">fresh</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Create a fresh propositional atom.
</div>
</td></tr>
<tr><td><a href="Expr_sat.html#VALfresh">fresh</a> [<a href="Expr_sat.html">Expr_sat</a>]</td>
<td><div class="info">
Make a fresh atom
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.Arg.html#VALfresh">fresh</a> [<a href="Tseitin_intf.Arg.html">Tseitin_intf.Arg</a>]</td>
<td><div class="info">
Generate fresh formulas
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALfresh_hname">fresh_hname</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Fresh names for clauses
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALfresh_lname">fresh_lname</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALfresh_name">fresh_name</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALfresh_tname">fresh_tname</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Print.html#VALfun_ttype">fun_ttype</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Print.html#VALfun_ty">fun_ty</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Expr_smt.Subst.S.html#VALget">get</a> [<a href="Expr_smt.Subst.S.html">Expr_smt.Subst.S</a>]</td>
<td><div class="info">
<code class="code">get v subst</code> returns the value associated with <code class="code">v</code> in <code class="code">subst</code>, if it exists.
</div>
</td></tr>
<tr><td><a href="Log.html#VALget_debug">get_debug</a> [<a href="Log.html">Log</a>]</td>
<td><div class="info">
Current debug level
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALget_elt">get_elt</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALget_elt_id">get_elt_id</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALget_elt_level">get_elt_level</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALget_elt_weight">get_elt_weight</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_intf.S.html#VALget_tag">get_tag</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Recover tag from a clause, if any
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="Eclosure.Key.html#VALhash">hash</a> [<a href="Eclosure.Key.html">Eclosure.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALhash">hash</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Term.html#VALhash">hash</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALhash">hash</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALhash">hash</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALhash">hash</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALhash">hash</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_intf.S.Term.html#VALhash">hash</a> [<a href="Expr_intf.S.Term.html">Expr_intf.S.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Formula_intf.S.html#VALhash">hash</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALhistory">history</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the history of learnt clauses, with no guarantees on order.
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALhyps">hyps</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the vector of assumptions used by the solver.
</div>
</td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALid">id</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Print.html#VALid_ttype">id_ttype</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Print.html#VALid_ty">id_ty</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALif_sat">if_sat</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_intf.S.html#VALif_sat">if_sat</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
Called at the end of the search in case a model has been found.
</div>
</td></tr>
<tr><td><a href="Theory_intf.S.html#VALif_sat">if_sat</a> [<a href="Theory_intf.S.html">Theory_intf.S</a>]</td>
<td><div class="info">
Called at the end of the search in case a model has been found.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALinterpretation">interpretation</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALis_empty">is_empty</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Test wether a substitution is empty
</div>
</td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALiter">iter</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Iterates over the bindings of the substitution.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALiter_assignable">iter_assignable</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_intf.S.html#VALiter_assignable">iter_assignable</a> [<a href="Plugin_intf.S.html">Plugin_intf.S</a>]</td>
<td><div class="info">
An iterator over the subterms of a formula that should be assigned a value (usually the poure subterms)
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALiter_aux">iter_aux</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALiter_elt">iter_elt</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Read access to the vector of variables created
</div>
</td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Dot.Arg.html#VALlemma_info">lemma_info</a> [<a href="Dot.Arg.html">Dot.Arg</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALlocal">local</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Add local assumptions
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="Expr_sat.html#VALmake">make</a> [<a href="Expr_sat.html">Expr_sat</a>]</td>
<td><div class="info">
Make a proposition from an integer.
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_and">make_and</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_atom">make_atom</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td><div class="info">
<code class="code">make_pred p</code> builds the atomic formula <code class="code">p = true</code>.
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALmake_boolean_var">make_boolean_var</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Returns the variable linked with the given formula, and whether the atom associated with the formula
      is <code class="code">var.pa</code> or <code class="code">var.na</code>
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALmake_clause">make_clause</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
<code class="code">make_clause name atoms size premise</code> creates a clause with the given attributes.
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_cnf">make_cnf</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td><div class="info">
<code class="code">make_cnf f</code> returns a conjunctive normal form of <code class="code">f</code> under the form: a
      list (which is a conjunction) of lists (which are disjunctions) of
      literals.
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_equiv">make_equiv</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_imply">make_imply</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_not">make_not</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_or">make_or</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALmake_xor">make_xor</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALmap">map</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALmcsat">mcsat</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.S.html#VALmem">mem</a> [<a href="Expr_smt.Subst.S.html">Expr_smt.Subst.S</a>]</td>
<td><div class="info">
<code class="code">get v subst</code> returns wether there is a value associated with <code class="code">v</code> in <code class="code">subst</code>.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALmerge">merge</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Merge two sorted atom list using a suitable comparison function.
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALmodel">model</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the model found if the formula is satisfiable.
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALnb_elt">nb_elt</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALneg">neg</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Returns the negation of the given atom
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.Arg.html#VALneg">neg</a> [<a href="Tseitin_intf.Arg.html">Tseitin_intf.Arg</a>]</td>
<td><div class="info">
Negation of atomic formulas
</div>
</td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALneg">neg</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td><div class="info">
Formula negation
</div>
</td></tr>
<tr><td><a href="Formula_intf.S.html#VALneg">neg</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td><div class="info">
Formula negation
</div>
</td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALnorm">norm</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Normalization functions as required by msat.
</div>
</td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALnorm">norm</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td><div class="info">
Returns a 'normalized' form of the formula, possibly negated
        (in which case return <code class="code">Negated</code>).
</div>
</td></tr>
<tr><td><a href="Formula_intf.S.html#VALnorm">norm</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td><div class="info">
Returns a 'normalized' form of the formula, possibly negated
      (in which case return <code class="code">Negated</code>).
</div>
</td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALof_atom">of_atom</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Constructors and destructors
</div>
</td></tr>
<tr><td><a href="Expr_smt.Term.html#VALof_id">of_id</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
Create a term from a variable
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALof_id">of_id</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td><div class="info">
Creates a type from a variable
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALof_lit">of_lit</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Internal.Make.html#VALpop">pop</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Pop a decision level for local assumptions.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALpop_watches">pop_watches</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp">pp</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp_atom">pp_atom</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp_clause">pp_clause</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp_dimacs">pp_dimacs</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp_lit">pp_lit</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALpp_reason">pp_reason</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Debug function for atoms and clauses (very verbose)
</div>
</td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALpred">pred</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Create a atom from a term.
</div>
</td></tr>
<tr><td><a href="Eclosure.Key.html#VALprint">print</a> [<a href="Eclosure.Key.html">Eclosure.Key</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Atom.html#VALprint">print</a> [<a href="Expr_smt.Atom.html">Expr_smt.Atom</a>]</td>
<td><div class="info">
Printing functions
</div>
</td></tr>
<tr><td><a href="Expr_smt.Term.html#VALprint">print</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
Printing functions
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALprint">print</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Subst.html#VALprint">print</a> [<a href="Expr_smt.Subst.html">Expr_smt.Subst</a>]</td>
<td><div class="info">
Prints the substitution, using the given functions to print keys and values.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Id.html#VALprint">print</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Printing for variables
</div>
</td></tr>
<tr><td><a href="Dedukti.Arg.html#VALprint">print</a> [<a href="Dedukti.Arg.html">Dedukti.Arg</a>]</td>
<td></td></tr>
<tr><td><a href="Backend_intf.S.html#VALprint">print</a> [<a href="Backend_intf.S.html">Backend_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Tseitin_intf.S.html#VALprint">print</a> [<a href="Tseitin_intf.S.html">Tseitin_intf.S</a>]</td>
<td><div class="info">
<code class="code">print fmt f</code> prints the formula on the formatter <code class="code">fmt</code>.
</div>
</td></tr>
<tr><td><a href="Tseitin_intf.Arg.html#VALprint">print</a> [<a href="Tseitin_intf.Arg.html">Tseitin_intf.Arg</a>]</td>
<td><div class="info">
Print the given formula
</div>
</td></tr>
<tr><td><a href="Expr_intf.S.Formula.html#VALprint">print</a> [<a href="Expr_intf.S.Formula.html">Expr_intf.S.Formula</a>]</td>
<td><div class="info">
Common functions
</div>
</td></tr>
<tr><td><a href="Expr_intf.S.Term.html#VALprint">print</a> [<a href="Expr_intf.S.Term.html">Expr_intf.S.Term</a>]</td>
<td><div class="info">
Common functions
</div>
</td></tr>
<tr><td><a href="Formula_intf.S.html#VALprint">print</a> [<a href="Formula_intf.S.html">Formula_intf.S</a>]</td>
<td><div class="info">
Common functions
</div>
</td></tr>
<tr><td><a href="Dot.Arg.html#VALprint_atom">print_atom</a> [<a href="Dot.Arg.html">Dot.Arg</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALprint_atom">print_atom</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALprint_clause">print_clause</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Pretty printing functions for atoms and clauses
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALprint_clause">print_clause</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
A nice looking printer for clauses, which sort the atoms before printing.
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALprint_lit">print_lit</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALprop">prop</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALprop">prop</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td></td></tr>
<tr><td><a href="Dedukti.Arg.html#VALprove">prove</a> [<a href="Dedukti.Arg.html">Dedukti.Arg</a>]</td>
<td></td></tr>
<tr><td><a href="Res_intf.S.html#VALprove">prove</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Given a clause, return a proof of that clause.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALprove_atom">prove_atom</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Given an atom <code class="code">a</code>, returns a proof of the clause <code class="code">[a]</code> if <code class="code">a</code> is true at level 0
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALprove_unsat">prove_unsat</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Given a conflict clause <code class="code">c</code>, returns a proof of the empty clause.
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALpush">push</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Create a decision level for local assumptions.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Expr_smt.Subst.S.html#VALremove">remove</a> [<a href="Expr_smt.Subst.S.html">Expr_smt.Subst.S</a>]</td>
<td><div class="info">
<code class="code">remove v subst</code> returns the same substitution as <code class="code">subst</code> except for <code class="code">v</code> which is unbound in the returned substitution.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Term.html#VALreplace">replace</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
<code class="code">replace (t, t') t''</code> returns the term <code class="code">t''</code> where every occurence of <code class="code">t</code>
      has been replace by <code class="code">t'</code>.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALresolve">resolve</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Performs a "resolution step" on a sorted list of atoms.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Log.html#VALset_debug">set_debug</a> [<a href="Log.html">Log</a>]</td>
<td><div class="info">
Set debug level
</div>
</td></tr>
<tr><td><a href="Log.html#VALset_debug_out">set_debug_out</a> [<a href="Log.html">Log</a>]</td>
<td><div class="info">
Change the output formatter.
</div>
</td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALset_elt_level">set_elt_level</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_types_intf.S.html#VALset_elt_weight">set_elt_weight</a> [<a href="Solver_types_intf.S.html">Solver_types_intf.S</a>]</td>
<td><div class="info">
Accessors for elements
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALsolve">solve</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Try and solves the current set of assumptions.
</div>
</td></tr>
<tr><td><a href="Solver_intf.S.html#VALsolve">solve</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Try and solves the current set of assumptions.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALstack">stack</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Term.html#VALsubst">subst</a> [<a href="Expr_smt.Term.html">Expr_smt.Term</a>]</td>
<td><div class="info">
Substitution over types.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Ty.html#VALsubst">subst</a> [<a href="Expr_smt.Ty.html">Expr_smt.Ty</a>]</td>
<td><div class="info">
Substitution over types.
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Internal.Make.html#VALtemp">temp</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the clauses coreesponding to the local assumptions.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALterm">term</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALterm_fun">term_fun</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
<code class="code">ty_fun name type_vars arg_types return_type</code> returns a fresh constant symbol,
      possibly polymorphic with respect to the variables in <code class="code">type_vars</code> (which may appear in the
      types in <code class="code">arg_types</code> and in <code class="code">return_type</code>).
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALto_list">to_list</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Resolution helpers
</div>
</td></tr>
<tr><td><a href="Internal.Make.html#VALtrail">trail</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the current trail.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALtrue_">true_</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Solver_intf.S.html#VALtrue_at_level0">true_at_level0</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
<code class="code">true_at_level0 a</code> returns <code class="code">true</code> if <code class="code">a</code> was proved at level0, i.e.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Id.html#VALttype">ttype</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Create a fresh type variable with the given name.
</div>
</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALttype">ttype</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALty">ty</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Create a fresh variable with given name and type
</div>
</td></tr>
<tr><td><a href="Expr_smt.Print.html#VALty">ty</a> [<a href="Expr_smt.Print.html">Expr_smt.Print</a>]</td>
<td></td></tr>
<tr><td><a href="Expr_smt.Id.html#VALty_fun">ty_fun</a> [<a href="Expr_smt.Id.html">Expr_smt.Id</a>]</td>
<td><div class="info">
Create a fresh type constructor with given name and arity
</div>
</td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALuf">uf</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Unionfind.Make.html#VALunion">union</a> [<a href="Unionfind.Make.html">Unionfind.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Internal.Make.html#VALunsat_conflict">unsat_conflict</a> [<a href="Internal.Make.html">Internal.Make</a>]</td>
<td><div class="info">
Returns the unsat clause found at the toplevel, if it exists (i.e if
      <code class="code">solve</code> has raised <code class="code">Unsat</code>)
</div>
</td></tr>
<tr><td><a href="Solver_intf.S.html#VALunsat_core">unsat_core</a> [<a href="Solver_intf.S.html">Solver_intf.S</a>]</td>
<td><div class="info">
Returns the unsat core of a given proof.
</div>
</td></tr>
<tr><td><a href="Res_intf.S.html#VALunsat_core">unsat_core</a> [<a href="Res_intf.S.html">Res_intf.S</a>]</td>
<td><div class="info">
Returns the unsat_core of the given proof, i.e the lists of conclusions of all leafs of the proof.
</div>
</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALupdate_job">update_job</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td><a href="Plugin_mcsat.html#VALupdate_watches">update_watches</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Plugin_mcsat.html#VALwatch">watch</a> [<a href="Plugin_mcsat.html">Plugin_mcsat</a>]</td>
<td></td></tr>
</table>
</body>
</html>